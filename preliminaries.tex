\chapter{Cryptographic Preliminaries}

This chapter provides some cryptographic background information which is
relevant for the attribute-based credential systems which we describe in the
next chapters. In particular we focus on public-key cryptography in which a key
consists of a public an a private part. These key pairs are constructed such
that deriving the private part of the key from the public part is equivalent to
solving a computational problem that is considered extremely difficult.

\section{RSA Cryptography}

In an RSA-based cryptosystem~\cite{RSA1978} a key pair consists a public part
$(n, e)$ and a private part $d$. The RSA modulus $n = p \cdot q$ is the product
of two primes $p$ and $q$ and the public exponent $e$ is a value that satisfies
$1 < e < \phi(n)$ and $gcd(e, \phi(n)) = 1$ where $\phi(n) = (p-1)(q-1)$ is
Euler's totient function\footnote{Euler's totient function $\phi(n)$ computes
the number of positive integers less then or equal to $n$ that are relatively
prime to $n$. An integer $k$ is relatively prime to $n$ if $gcd(k, n) = 1$.}.
The private exponent $d$ is a value that satisfies $1 < d < \phi(n)$ and
$e \cdot d = 1 \mod \phi(n)$, hence it can be computed as
$d = e^{-1} \mod \phi(n)$. When $p$ and $q$ are know, this computation is easy,
but computing $d$ based on just $n$ and $e$ is proved to be computationally
equivalent to determining the prime factors $p$ and $q$ of $n$, which is known
as the integer factorisation problem, a number-theoretic problem which is
considered intractable for large integers.

Such a key pair can then be used to encrypt a message $m$ into an RSA ciphertext
$c = m^e \mod n$ using Algorithm~\ref{alg:RSA-encrypt}. Decryption of such a
ciphertext using Algorithm~\ref{alg:RSA-decrypt} is based on the fact that
\begin{equation*}
  c^d = (m^e)^d = m^{e \cdot d} = m \mod n\text.
\end{equation*}

\begin{algorithm}[ht]
  \caption{RSA encryption.}
  \label{alg:RSA-encrypt}
  \addtolength{\baselineskip}{1mm}
  \begin{algorithmic}[1]
    \Function{RSA-encrypt}{$(n, e), m$}
      \State $c \gets m^e \mod n$
      \Return $c$
    \EndFunction
  \end{algorithmic}
\end{algorithm}
\begin{algorithm}[ht]
  \caption{RSA decryption.}
  \label{alg:RSA-decrypt}
  \addtolength{\baselineskip}{1mm}
  \begin{algorithmic}[1]
    \Function{RSA-encrypt}{$(n, e), c, d$}
      \State $m \gets c^d \mod n$
      \Return $m$
    \EndFunction
  \end{algorithmic}
\end{algorithm}

The problem of recovering the message $m$ based on the ciphertext $m^e \mod n$
and public key $(n, e)$ is known as the \emph{RSA problem}. This is equivalent
to finding $e$th roots modulo $n$ which is assumed to be as difficult as the
integer factorisation problem. Hence, the \emph{RSA assumption} states that the
probability that an attacker can solve the RSA problem is negligible.

In a similar fashion, this construction can also be used to create digital
signatures. To generate an RSA signature with Algorithm~\ref{alg:RSA-sign}, the
signer computes the message digest $h = \Call{Hash}{m}$ of the message to be
signed $m$ using a cryptographic hash function $\Call{Hash}{}$. This $h$, which
serves as a fingerprint of the original message, is then raised to the private
exponent. The result of this operation is the signature $s = h^d \mod n$ over
the message $m$.
Such an RSA signature can be verified using Algorithm~\ref{alg:RSA-verify}. The
verifier recovers the fingerprint $\hat{h} = s^e \mod n$ from the signature
value $s$ using the public exponent $e$ and checks whether this matches with the
message digest of the message $m$. If they match, the signature is valid,
otherwise the signature is invalid. The security of this RSA signature scheme is
also based on the RSA assumption.

\begin{algorithm}[H]
  \caption{RSA signature generation.}
  \label{alg:RSA-sign}
  \addtolength{\baselineskip}{1mm}
  \begin{algorithmic}[1]
    \Function{RSA-sign}{$(n, e), m, d$}
      \State $h \gets \Call{Hash}{m}$
      \State $s \gets h^d \mod n$
      \Return $s$
    \EndFunction
  \end{algorithmic}
\end{algorithm}
\begin{algorithm}[H]
  \caption{RSA signature verification.}
  \label{alg:RSA-verify}
  \addtolength{\baselineskip}{1mm}
  \begin{algorithmic}[1]
    \Function{RSA-verify}{$(n, e), m, s$}
      \State $\hat{h} \gets s^e \mod n$
      \If{$\hat{h} \neq \Call{Hash}{m}$}
        \Return \Call{Invalid}{}
      \EndIf
      \Return \Call{Valid}{}
    \EndFunction
  \end{algorithmic}
\end{algorithm}

Some other signature schemes based on the RSA cryptosystem, such as the
Camensich-Lysyanskaya scheme which is described in Section~\ref{sec:CL-scheme},
only use the RSA modulus $n$ as the public part of the key, whereas the private
part consists of the primes $p$ and $q$. This allows them to generate a fresh
exponent $e$ for each signature which will then become part of the signature.
Since an attacker can now control both the signature and the exponent, solving
the RSA problem has become easier. Hence a stronger assumption is needed. This
\emph{strong RSA assumption} states that the probability that an attacker can
solve the RSA problem is negligible, even when the attacker can chose the public
exponent $e$.

\section{Discrete Logarithm Cryptography}

In a discrete logarithm-based cryptosystem~\cite{DH1976,ElGamal1985} a key pair
is accompanied with a description of the prime-order group in which the
computations take place. As an example we use $(p, q, g)$, where $p$ is a prime,
$q$ is a prime divisor of $p-1$, and $g$ is a generator, with order $q$, of a
subgroup of $\Z^*_p$. A private part of the key in such system is a random value
$x$ and the corresponding public part is $h = g^x \mod p$. The problem of
computing the private part $x = \log_g h$, based on the description of the group
$(p, q, g)$ and the public part $h$, is known as the \emph{discrete logarithm
problem}.

Such a key pair can be used to computed a shared key with another party that
uses the same group parameters. To this end, both parties send their public key
to each other and compute the modular exponentiation of the received value and
their private key, as depicted in Figure~\ref{msc:DH}. The result of this
computation can then be used as a shared key since
\begin{equation*}
  h_2^{x_1} = (g^{x_2})^{x_1} = g^{x_2 \cdot x_1}
  = k = g^{x_1 \cdot x_2} = (g^{x_1})^{x_2} = h_1^{x_2} \mod p
\end{equation*}
The problem of computing $k$, based on both public keys $h_1$ and $h_2$ and the
group description $(p, q, g)$, is assumed to be as difficult as the discrete
logarithm problem and is called the \emph{Diffie-Hellman problem}. A related
problem is to determine whether a value $y$ is created using $h_1$ and $h_2$,
hence $y = g^{x_1 \cdot x_2}$, or not. This is known as the \emph{decisional
Diffie-Hellman problem}.

\begin{figure}[hb]
  \centering
  \includegraphics[scale=.45]{mscs/dh}
  \caption{Diffie-Hellman key agreement protocol.}
  \label{msc:DH}
\end{figure}

Many signature schemes have been based on the discrete logarithm problem, for
example the Chaum-Pedersen scheme which is described in
Section~\ref{sec:CP-scheme}, but also the Digital Signature Algorithm (DSA),
described in Algorithms~\ref{alg:DSA-sign} and~\ref{alg:DSA-verify}, which is
part of the Digital Signature Standard of the United States government.

\begin{algorithm}[H]
  \caption{DSA signature generation.}
  \label{alg:DSA-sign}
  \addtolength{\baselineskip}{1mm}
  \begin{algorithmic}[1]
    \Function{DSA-sign}{$(p, q, g), m, x$}
      \State $r \gets 0$
      \While{$r = 0 \mod p$}
        \State $k \gets \Call{Random}{}$
        \State $r \gets (g^k \mod p) \mod q$
      \EndWhile
      \State $c \gets \Call{Hash}{m}$
      \State $s \gets k^{-1} \cdot (c + x \cdot r) \mod q$
      \Return $(r, s)$
    \EndFunction
  \end{algorithmic}
\end{algorithm}
\begin{algorithm}[H]
  \caption{DSA signature verification.}
  \label{alg:DSA-verify}
  \addtolength{\baselineskip}{1mm}
  \begin{algorithmic}[1]
    \Function{DSA-verify}{$(p, q, g), m, (r, s), h$}
      \State $c \gets \Call{Hash}{m}$
      \State $u \gets c \cdot s^{-1} \mod q$
      \State $v \gets r \cdot s^{-1} \mod q$
      \State $\hat{r} \gets (g^u \cdot g^v \mod p) \mod q$
      \If{$\hat{r} \neq r$}
        \Return \Call{Invalid}{}
      \EndIf
      \Return \Call{Valid}{}
    \EndFunction
  \end{algorithmic}
\end{algorithm}



\section{Elliptic Curve Cryptography}

\subsection{Elliptic Curves}

\begin{definition}[Elliptic Curve]\label{def:elliptic_curve}
  Given a finite field $\F{q}$ containing $q$ elements, where $q$ is a prime
  power, an elliptic curve $E$ over $\F{q}$ is defined by the equation
  \begin{equation}\label{eqn:elliptic_curve}
    E: y^2 = x^3 + a x + b
  \end{equation}
  where $a, b \in \F{q}$ are the curve parameters and $4 a^3 + 27 b^2 \neq 0$.
  The set of all points $P = (x, y)$ on this curve $E$ is denoted as
  \begin{equation*}
    E(\F{q}) = \{ (x, y) \in \F{q} \times \F{q} : y^2 = x^3 + a x + b \}
                         \cup \{ \infty \}
  \end{equation*}
  where $\infty$ is a special point called the \emph{point at infinity}.
\end{definition}

If we know the $x$-coordinate of a point on the curve, the square of the
corresponding $y$-coordinate is known, namely as $y^{2} = x^{3} + ax + b$.
By taking the square root of $x^{3} + ax + b$ we find either $y$ or $-y$.
This forms the basis of ``point compression'', for compact representation
of points.  This is important for the implementation, because Diffie-Hellman
on a Java smart card only produces the $x$-coordinate of a multiplication.

\subsection{Operations}

\begin{enumerate}
  \item \emph{Point Negation}
    If $P = (x, y) \in E(\F{q})$ then $(x, y) + (x, -y) = \infty$. The point
    $(x, -y)$ is denoted by $-P$ and is called the \emph{negative of $P$}.
    Also, $-\infty = \infty$.
  \item \emph{Point addition}
    Let $P = (x_P, y_P) \in E(\F{q})$ and $Q = (x_Q, y_Q) \in E(\F{q})$, where
    $P \neq \pm Q$. Then $P + Q = R = (x_R, y_R) \in E(\F{q})$, where
    \begin{equation*}
      x_R = \left(\dfrac{y_Q - y_P}{x_Q - x_P}\right)^2 - x_P - x_Q
      \text{ and }
      y_R = \left(\dfrac{y_Q - y_P}{x_Q - x_P}\right) (x_P - x_R) - y_P
      \text{.}
    \end{equation*}
    Also, $P + \infty = \infty + P = P$ for all $P \in E(\F{q})$.
  \item \emph{Point doubling}
    Let $P = (x_P, y_P) \in E(\F{q})$, where $P \neq -P$. Then
    $2P = R = (x_R, y_R) \in E(\F{q})$, where
    \begin{equation*}
      x_R = \left(\dfrac{3 x_P^3 + a}{2 y_P}\right)^2 - 2 x_P
      \text{ and }
      y_R = \left(\dfrac{3 x_P^3 + a}{2 y_P}\right) (x_P - x_R) - y_P
      \text{.}
    \end{equation*}
    Also, $2\infty = \infty$.
  \item \emph{Point multiplication}
    Given an integer $k$ and a point $P$ the multiplication is denoted as
    $k \cdot P$. To compute this multiplication various methods exist. A basic
    solution is the repeated-double-and-add method given in Algorithm~\ref{alg:ec_point_multiplication}.
\end{enumerate}

\begin{algorithm}
  \caption{Elliptic curve point negation: $R = -P$}
  \label{alg:ec_point_negation}

  \begin{algorithmic}[1]
    \Function{ECPointNegation}{$P$}
      \If{$P = \infty$}
        \Return $\infty$
      \Else
        \State $(x_P, y_P) \gets P$
      \EndIf

      \smallskip
      \Return $(x_P, -y_P)$
    \EndFunction
  \end{algorithmic}
\end{algorithm}


\begin{algorithm}
  \caption{Elliptic curve point addition: $R = P + Q$}
  \label{alg:ec_point_addition}

  \begin{algorithmic}[1]
    \Function{ECPointAddition}{$P$, $Q$}
      \If{$P = \infty$}
        \Return $Q$
      \ElsIf{$P = Q$}
        \Return $2 \cdot P$
      \ElsIf{$P = -Q$ or $Q = \infty$}
        \Return $\infty$
      \Else
        \State $(x_P, y_P) \gets P$
        \State $(x_Q, y_Q) \gets Q$
      \EndIf
      \medskip

      \State $x \gets \left(\dfrac{y_Q - y_P}{x_Q - x_P}\right)^2 - x_P - x_Q$ % FIXME: \mod q
      \State $y \gets \left(\dfrac{y_Q - y_P}{x_Q - x_P}\right) (x_P - x_R) - y_P$ % FIXME: \mod q

      \smallskip
      \Return $(x, y)$
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Elliptic curve point doubling: $R = 2 \cdot P$}
  \label{alg:ec_point_doubling}

  \begin{algorithmic}[1]
    \Function{ECPointDoubling}{$P$}
      \If{$P = \infty$}
        \Return $P$
      \Else
        \State $(x_P, y_P) \gets P$
      \EndIf
      \medskip

      \State $x_R \gets \left(\dfrac{3 x_P^3 + a}{2 y_P}\right)^2 - 2 x_P$ % FIXME: \mod q
      \State $y_R \gets \left(\dfrac{3 x_P^3 + a}{2 y_P}\right) (x_P - x_R) - y_P$ % FIXME: \mod q

      \smallskip
      \Return $(x_R, y_R)$
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Elliptic curve point multiplication: $R = k \cdot P$ (repeated-double-and-add; right-to-left binary method)}
  \label{alg:ec_point_multiplication}

  \begin{algorithmic}[1]
    \Function{ECPointMultiplication}{$k$, $P$}
      \State $(k_{l-1}, \dots, k_1, k_0) \gets k$ \Comment{binary representation of $k$}
      \State $R \gets \infty$

      \For{$i$ from $0$ to $l - 1$}
        \If{$k_i = 1$}
          \State $R \gets R + P$
        \EndIf
        \State $P \gets 2P$
      \EndFor

      \smallskip
      \Return $R$
    \EndFunction
  \end{algorithmic}
\end{algorithm}

%%[BHJMV]
For elliptic curve cryptography the field $\F{q}$ is of the form $\F{p^n}$ for
some prime number $p$ and $n \in \N$ ($p \neq 2,3)$. The solutions of
equation~(\ref{eqn:elliptic_curve}) form an abelian group with point addition
as the group operation and the point at infinity as the zero-element. The
condition $4a^3 + 27b^2 \neq 0$ is required for $E$ to be non-singular, as
required for cryptographic applications. For cryptography we need a finite
cyclic group in which the group operation is efficiently computable, but the
discrete logarithm problem is very difficult to solve. Elliptic curve groups
meet these criteria when the underlying field is finite and the size of $p$ is
at least 160~bits.

\subsection{Elliptic Curve Discrete Logarithm Problem}

Let $E$ be an elliptic curve over $\F{q}$ and let $P \in E$ be a point of order
$k$. Let $Q \in \langle P \rangle$ be a point generated by $P$, that is,
$Q = \alpha \cdot P$ for $\alpha$ where $0 \leq \alpha < k$. The problem of
finding the logarithm $\alpha$ for given $P$ and $Q$ is called the elliptic
curve discrete logarithm problem (ECDLP).


\subsection{Pairings\label{sec:pairings}}

A bilinear pairing is a map $\mathbb{G}_1 \times \mathbb{G}_2 \rightarrow
\mathbb{G}_T$ where $\mathbb{G}_1$ and $\mathbb{G}_2$ are typically additive
groups and $\mathbb G_T$ is a multiplicative group and the map is bilinear, that
is, linear in both components. Many pairings are used in cryptography such as the
Tate pairing, ate pairing and the most recent R-ate
pairing~\cite{Vercauteren09}. For all these pairings one often uses specific cyclic
subgroups of $E(\mathbb{F}_{p^k})$ as $\mathbb{G}_1$ and $\mathbb{G}_2$
and $\mathbb{F}_{p^k}^*$ as $\mathbb{G}_T$.

The bilinearity property can be written as follows:
\begin{equation*}
  \begin{array}{rcl}
    e(P + P',\; Q) & = & e(P,\; Q)\cdot e(P',\; Q) \\
     & \text{and} & \\
    e(P,\; Q + Q') & = & e(P,\; Q)\cdot e(P,\; Q')
  \end{array}
\end{equation*}
As a result, $e(n\cdot P,\; m\cdot Q) = e(P,\; Q)^{n\,m}$. Pairings are used for many
(new) cryptographic protocols~\cite{BSS05}, such as short
signatures~\cite{BonehLS04}, three-party one-round key agreement~\cite{Joux04},
identity based encryption~\cite{BonehFranklin01} and anonymous
credentials~\cite{CamenischLysyanskaya04}.

\subsection{Barreto-Naehrig Curves}

Pairing friendly elliptic curves are curves with a small embedding degree and
large prime-order subgroup. In 2005, Barreto and Naehrig (BN) discovered a new
method for constructing pairing friendly elliptic curves of prime order over a
prime field~\cite{BN06}. More precisely, BN curves are defined over $\F{p}$
where $p = p(u) = 36 u^4 + 36 u^3 + 24 u^2 + 6 u + 1$ for $u \in \Z$ such that
$p$ is prime. The order of a BN curve is a prime $n$ where
$n = n(u) = 36 u^4 + 36 u^3 + 18 u^2 + 6 u + 1$. Hence, a BN curve is
constructed by generating integers $u$ until both $p(u)$ and $n(u)$ are prime
numbers. The embedding degree of BN curves is 12 and we detail the parameters
for our case when they are used.

Here we use pairings of the form $e: E(\F{p}) \times E(\F{p^k}) \to \F{p^k}$,
obtained by taking $\G{1} = \G{2} = \F{p^k}$ and using the obvious inclusion
$\F{p} \to \F{p^k}$ in the first argument. The number $k$ is known in this
context as the embedding degree. As previously mentioned, one uses $k = 12$ for
BN-curves.

\subsection{DH and DSA for Elliptic Curves}\label{sec:dhdsa}

The Diffie-Hellman key agreement protocol (DH) and the Digital Signature
Algorithm (DSA) are easily adapted to the ECC case as in~\cite{BSS05}
and~\cite{JM00} respectively. We recall the protocols, which in this case are
called ECDH and ECDSA.

\subsubsection{EC Diffie-Hellman Key Agreement (ECDH)}

Alice ($A$) and Bob ($B$) wish to agree on a
secret key over an insecure channel. They first agree on the set
of domain parameters $(\mathbb{F}_q, E, n,
h, G)$. Here, $E$ is an elliptic curve over
$\mathbb{F}_q$, $G$ is a generating (publicly known) point in
the elliptic curve group of order $n$ and the integer
$h$ is called the cofactor. For the cofactor we have:
$\# E(\mathbb{F}_q) = h \, n.$
Due to the security of the ECDLP one usually
selects a curve for which $h \leq 4$.
Any random point of sufficiently high order on
an elliptic curve $E$ can be used as a key.

\begin{figure}
  \centering
  \includegraphics[scale=.4]{mscs/ecdh}
  \caption{EC Diffie-Hellman key agreement protocol}\label{fig:ecdh}
\end{figure}

\paragraph{Key Agreement}

Each time a shared key is required, the following steps, as depicted in \figurename~\ref{fig:ecdh}, have to be performed.

\begin{enumerate}
  \item $A$ chooses a random secret $x$, where $1 \leq x \leq n-1$, as her private
    key and sends $B$ the corresponding public key $x \cdot G$
  \item $B$ chooses a random secret $y$, where $1 \leq y \leq n-1$, as his private
    key and sends $A$ the corresponding public key $y \cdot G$.
  \item $B$ receives $x \cdot G$ and computes the shared key as
    $k = y \cdot (x \cdot G) = (xy) \cdot G$.
  \item $A$ receives $y \cdot G$ and computes the shared key as
    $k = x \cdot (y \cdot G) = (xy) \cdot G$.
\end{enumerate}

So, they both end up with the same point as the common key: $k = xy \cdot G$.
An adversary Eve may have knowledge of $G$, $x\cdot G$,
and $y\cdot G$ but not of $x$ or $y$. She wants to determine number $xy\cdot G$. This
task is called the ``(computational) Diffie-Hellman problem for elliptic curves''.

9.2 DL/ECKAS-DH1
DL/ECKAS-DH1 is the Discrete Logarithm and Elliptic Curve Key Agreement Scheme, Diffie-Hellman
version, where each party contributes one key pair.
\textbf{Scheme options}
The following options shall be established or otherwise agreed upon between the parties to the scheme:
\begin{itemize}
  \item A secret value derivation primitive, which shall be: DLSVDP-DH, DLSVDP-DHC, ECSVDP-DH, or ECSVDP-DHC
  \item For a -DHC secret value derivation primitive, an indication as to whether or not compatibility with the corresponding -DH primitive is desired
  \item A key derivation function, which should be KDF1 (see 13.1), or a function designated for use with DL/ECKAS-DH1 in an amendment to this standard
\end{itemize}
The above information may remain the same for any number of executions of the key agreement scheme, or
it may be changed at some frequency. The information need not be kept secret.
\textbf{Key agreement operation}
A sequence of shared secret keys, K 1 , K 2 , ..., K t , shall be generated by each party by performing the
following or an equivalent sequence of steps:
\begin{enumerate}
  \item Establish the valid set of DL or EC domain parameters with which the parties’ key pairs shall be associated.
  \item Select a valid private key s for the operation, associated with the parameters established in step 1.
  \item Obtain the other party’s purported public key w′ for the operation, associated with the parameters established in step 1.
  \item (Optional) If the selected secret value derivation primitive is DLSVDP-DHC or ECSVDP-DHC, then validate that w′ is an element in the appropriate group (i.e., in GF (q) for DL or on the elliptic curve for EC; see 6.2.2 and 7.2.2); otherwise, validate that w′ is a valid public key. If any validation fails, output “invalid public key” and stop.
  \item Compute a shared secret value z from the private key s and the other party’s public key w′ with the selected secret value derivation primitive (see 9.2.1).
  \item Convert the shared secret value z to an octet string Z using FE2OSP.
  \item For each shared secret key to be agreed on (a.) Establish or otherwise agree on key derivation parameters P i for the key.
 (b.) Derive a shared secret key K i from the octet string Z and the key derivation parameters P i with the selected key derivation function (see 9.2.1).
\end{enumerate}

\subsubsection{EC Digital Signature Algorithm (ECDSA)}

The ECDSA is specified by an elliptic curve $E$ defined
over $\mathbb{F}_q$ and a publicly known point
$G \in E$ of prime order $n$. As above, a private key of Alice is a scalar $z$ and the
corresponding public key is $Q = z \cdot G \in E$. The ECDSA requires a hash
function in addition and consists of two parts as explained below.

\paragraph{Signature Generation}

In order to sign a message $m$, $A$ should perform the following steps:

\begin{enumerate}
  \item Select a random integer $k$, where $1 \leq k \leq n-1$.
  \item Compute $(x_1,\; y_1) = k \cdot G$.
  \item Compute $r = x_1\, \bmod n$. If $r = 0$, then go back to the step 1.
  \item Compute $s = k^{-1} (h(m)+z \, r)\bmod n$, where $h$ is a hash function.
    If $s = 0$, then go to step 1.
  \item $A$'s signature for the message $m$ is the pair $(r,\; s)$.
\end{enumerate}

\paragraph{Signature Verification}

In order to verify $A$'s signature on $m$, $B$ performs the following steps:

\begin{enumerate}
  \item Obtain an authenticated copy of $A$'s public key $Q$.
  \item Verify that $r$ and $s$ are integers in the interval $[1, n-1]$.
  \item Compute $w = s^{-1} \bmod n$ and $h(m)$.
  \item Compute $u_1 = h(m) \, w \bmod n$ and $u_2 = r\,w \bmod n$.
  \item Compute $(x_0,\; y_0) = u_1 \cdot G + u_2 \cdot Q$ and
    $v = x_0 \bmod n$.
  \item Accept the signature if and only if $v = r$.
\end{enumerate}
\section{Zero-knowledge proofs}

\subsection{Zero-knowledge protocols}

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[scale=.45]{mscs/schnorr}
    \caption{$PK\{(\alpha) : h = g^\alpha \}$}
    \label{msc:schnorr}
  \end{subfigure}
  \quad
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[scale=.45]{mscs/schnorr_mod}
    \caption{$PK\{(\alpha) : h \equiv g^\alpha \mod n \}$}
    \label{msc:schnorr_mod}
  \end{subfigure}
  \caption{Schnorr's zero-knowledge protocol~\cite{Schnorr1991} for prime order groups (a) and for groups modulo a composite (b).}
  \label{fig:schnorr}
\end{figure}

Schnorr

\subsection{Zero-knowledge proofs}

The Fiat-Shamir heuristic~\cite{FiatShamir1987} can be used to transform a zero-knowledge protocol into a non-interactive zero-knowledge proof. To achieve this the challenge $c$ is not retrieved from the verifier but computed as follows: $$c \leftarrow H(m,a)$$ where $H$ is a cryptographic hash function, $m$ is some message to be included (to be signed) and $a$ is the commitment. Both the commitment $a$ and the response $r$ are calculated as usual. The result is a signature $(c,r)$ on $m$. This can be verified by checking whether $$c = H(m, g^r h^{-c})$$ holds. It should hold since $g^r h^{-c} = g^{u + cx} h^{-c} = g^{u + cx} (g^x)^{-c} = g^u = a$.

\subsection{Composition of zero-knowledge proofs}

\subsubsection{Combining}

Constructing a proof for $PK\{(\dots) : P_1 \;\land\; P_2 \}$ where $P_1$ and $P_2$ do not share any variables from $(\dots)$ can be achieved by constructing proofs for $P_1$ and $P_2$ \emph{using the same challenge} $c$.

\subsubsection{Equality}

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[scale=.45]{mscs/okamoto}
    \caption{$PK\{(\alpha, \beta) : h = g_1^\alpha g_2^\beta \}$}
    \label{msc:okamoto}
  \end{subfigure}
  \quad
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[scale=.45]{mscs/equality}
    \caption{$PK\{(\alpha, \beta, \gamma) : h = g_1^\alpha g_2^\beta \land \tilde{h} = \tilde{g}_1^\alpha \tilde{g}_2^\gamma\}$}
    \label{msc:equality}
  \end{subfigure}
  \caption{Okamoto's zero-knowledge protocol~\cite{Okamoto1993} for multi-exponents (a) and an adaption for equality (of the first exponent) composition (b).}
  \label{fig:okamoto}
\end{figure}

Constructing a proof for $PK\{(\dots) : P_1 \;\land\; P_2 \}$ where $P_1$ and $P_2$ share variables from $(\dots)$ can be achieved by constructing proofs for $P_1$ and $P_2$ \emph{using the same challenge} $c$ and \emph{using the same randoms and responses} $u_i$ and $r_i$.


\subsubsection{OR} ...


