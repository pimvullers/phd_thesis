\chapter{Identity Mixer}

\section{Camenisch-Lysyanskaya Signature Scheme}

Camenisch and Lysyanskaya~\cite{CamenischLysyanskaya2002,Lysyanskaya2002}
present a provably secure signature scheme and provide protocols for
\begin{itemize}
  \item issuing a signature on a committed value, that is, blind
    signatures~\cite{Chaum1983}, and
  \item proving knowledge of a signature (on a committed value).
\end{itemize}
This makes this scheme a suitable building block for privacy-preserving
technologies like anonymous credential systems.

This description is based on the Direct Anonymous Attestation explanation by
Camenisch~\cite{Camenisch2007} and the specification of the Identity Mixer
cryptographic library~\cite{Idemix_Crypto2010}. These documents incorporate
improvements over the original scheme~\cite{CamenischLysyanskaya2002} presented
by Brickell, Camenisch, and Chen~\cite{BrickellCC2004} and by Camenisch and
Groth~\cite{CamenischGroth2004}.

\subsection{Basic Signature Scheme}\label{sec:cl_basic}

\subsubsection{Key Generation}\label{sec:cl_basic-keygen}

\paragraph{Input}
  the number of supported messages $L$

\paragraph{Output}
  public key $(n, R_1, \dots, R_L, S, Z)$ and
  secret key $p$ where
\begin{description}
  \item[$n$] $= pq$ is a special RSA modulus of length $l_n$ for safe primes
    $p = 2p' + 1$ and $q = 2q' + 1$ where $p'$ and $q'$ are primes
  \item[$S$] $\in_R QR_n$ is a generator (with order $\#QR_n = p'q'$) of the
    group of quadratic residues (mod $n$)
    $QR_n = \{x \in \mathbb{Z}_n | \exists_{y \in \mathbb{Z}_n} x \equiv y^2 \mod n \}$
  \item[$R_1, \dots, R_L$] $\in_R \langle S \rangle$ are the bases for the
    messages to be signed where $\langle S \rangle$ is the subgroup of $QR_n$
    generated by $S$
  \item[$Z$] $\in_R \langle S \rangle$ is an auxiliary value such that all
    computations remain within $\langle S \rangle$
\end{description}

\subsubsection{Signature generation}\label{sec:cl_basic-sign}

\paragraph{Input} messages $m_1, \dots, m_L \in \pm \{0,1\}^{l_m}$

\paragraph{Output} signature $(e, v, A)$ where
\begin{description}
  \item[$e$] is a random (to prevent combining $A$'s) prime number (used as a RSA public key) of length $l_e > l_m + 2$
  \item[$v$] is a random number (used for blinding) of length $l_v = l_n + l_m + l_r$ where $l_r$ is a security parameter
  \item[$A$] $=\left(\dfrac{Z}{S^v \prod_{i=1}^{L} R_i^{m_i}} \right)^{1/e} \mod n$ is a RSA signature over $\dfrac{Z}{S^v \prod_{i=1}^{L} R_i^{m_i}}$
\end{description}

\subsubsection{Signature verification}\label{sec:cl_basic-verify}

\paragraph{Verify} the following for a signature $(e, v, A)$ on messages $m_1, \dots, m_L$
\begin{equation*}
  Z \equiv A^e S^v \prod_{i=1}^{L} R_i^{m_i} \mod n
  \quad\land\quad
  \bigwedge_{i=1}^{L} m_i \in \pm \{0,1\}^{l_m}
  \quad\land\quad
  2^{l_e-1} < e < 2^{l_e}
\end{equation*}

\subsection{Blind signatures}\label{sec:cl_blind}

\subsubsection{Key Generation}\label{sec:cl_blind-keygen}

\paragraph{Input} the number of supported messages $L$

\paragraph{Output} public key $(n, R_1, \dots, R_L, S, Z)$ and secret key
  $p (, q)$ where
\begin{description}
  \item[$n$] $= pq$ is a special RSA modulus of length $l_n$ for safe primes
    $p = 2p' + 1$ and $q = 2q' + 1$ where $p'$ and $q'$ are primes
  \item[$S$] $\in_R QR_n$ with order $\#QR_n = p'q'$ is a generator of $QR_n$
    where $QR_n = \{ x : x,y \in \mathbb{Z}_n \land x \equiv y^2 \mod n \}$ is
    the group of quadratic residues (mod $n$)
  \item[$R_i$] $= S^{x_i} \mod n$ where $x_i \in_R [2, p'q' - 1]$ for
    $1 \leq i \leq L$ are the bases for the messages to be signed
  \item[$Z$] $= S^{x_z} \mod n$ where $x_z \in_R [2, p'q' - 1]$ is an auxiliary
    value such that all computations remain within $\langle S \rangle$
\end{description}

\paragraph{Proof} proof $(c, r_{(i,j)}, s_j)$, for $1 \leq i \leq L$ and
  $1 \leq j \leq l_H$, of correct public key construction (based
  on~\cite[Appendix A]{BrickellCC2004})
\begin{multline*}
  SPK \{ (\alpha_z, \alpha_1, \dots, \alpha_L) : \\
  \bigwedge_{i = 1}^{L} R_i \equiv S^{\alpha_i} \mod n
  \quad\land\quad
  Z \equiv S^{\alpha_z} \mod n
  \} (n, R_1, \dots, R_L, S, Z)
\end{multline*}
\begin{enumerate}
  \item $\tilde{R}_{(i,j)} = S^{u_{(i,j)}} \mod n$ and
    $\tilde{Z}_j = S^{v_j} \mod n$ where
    $u_{(i,j)}, v_j \in_R [1,p'q']$ for
    $1 \leq i \leq L$ and $1 \leq j \leq l_H$
  \item $c = H(n, R_i, S, Z, \tilde{R}_{(i,j)}, \tilde{Z}_j)$ for
    $1 \leq i \leq L$ and $1 \leq j \leq l_H$
  \item $r_{(i,j)} = u_{(i,j)} - c_j x_i \mod p'q'$ and
    $s_j = v_j - c_j x_z \mod p'q'$ where $c_j$ is the $j$-th bit of $c$ for
    $1 \leq i \leq L$ and $1 \leq j \leq l_H$
\end{enumerate}
Binary challenges are required due to the security proof for zero-knowledge.
% Special soundness: take two runs with the same commitment, but different
% challenges (and responses): (a, c, r) and (a, c', r').
%
% This gives y = g^{(r-r')/(c-c')}, hence witness w = (r-r')/(c-c').
% This can only be computed if:
% 1) c, c' are binary, thus delta(c) = +/- 1, or
% 2) under SRSA: delta(c) | delta(r) allows integer division
%       not(delta(c) | delta(r)) breaks SRSA, that is, it gives a root of g:
%            y^delta(c) = g^delta(r)    1 = a.delta(r) + b.delta(c)
%            g = g^{a.delta(r)} g^{b.delta(c)}
%              = y^{a.delta(c)} g^{b.delta(c)}
%              = (g^b y^a)^delta(c)
%
% The issuer knows the factorisation of n, and hence the order of the group, so
% SRSA does not hold in this case, so binary challenges is the only option here.

\paragraph{Verify}
\begin{equation*}
  c = H(n, R_i, S, Z, R_i^{c_j} S^{r_{(i,j)}}, Z^{c_j} S^{s_j}) \text{ for }
  1 \leq i \leq L \text{ and } 1 \leq j \leq l_H
\end{equation*}
This works because: $Z^{c_j} S^{s_j} = (S^{x_z})^{c_j} S^{s_j} = (S^{x_z})^{c_j} S^{v_j - c_j x_z} = S^{v_j} = \tilde{Z}_j$
and $R_i^{c_j} S^{r_{(i,j)}} = (S^{x_i})^{c_j} S^{r_{(i,j)}} = (S^{x_i})^{c_j} S^{u_{(i,j)}-c_j x_i} = S^{u_{(i,j)}} = \tilde{R}_{(i,j)}$.

\subsubsection{Signature generation}\label{sec:cl_blind-sign}

\paragraph{Input} messages $m_1, \dots, m_L$ and key $p, (n, R_1, \dots, R_L, S, Z)$ where
\begin{description}
  \item[$m_i$] $\in \pm \{0,1\}^{l_m'}$ where $l_m' \leq l_m - l_\varnothing - l_\mathcal{H} - 2$ is the size of the messages
  \item[$R_1, \dots, R_L, Z$] $\in \langle S \rangle$ assured by the proof generated during key generation
\end{description}

\paragraph{Output} signature $(e, v, A)$ as depicted in Figure~\ref{msc:cl_blind-sign}, whereas the zero-knowledge protocols are given in Figures~\ref{msc:cl_blind-sign_pku} and~\ref{msc:cl_blind-sign_pka} respectively.

%$R$: $v' \in_R \{0,1\}^{l_n+l_\varnothing}; U = S^{v'} \prod_{i=1}^{L'} R_i^{m_i} \mod n$ \\
%$R \longrightarrow S$: $U, PK\{(\mu_1, \dots, \mu_{L'}, \nu') : U \equiv \pm S^{\nu'} \prod_{i=1}^{L'} R_i^{\mu_i} \mod n \land \mu_1, \dots, \mu_{L'} \in \pm\{0,1\}^{l_m} \}$ \\
%$S$: $\hat{v} \in_R \{0,1\}^{l_v-1}; e \in_R [2^{l_e-1} + 1, 2^{l_e} -1]; v'' = \hat{v} + 2^{l_v - 1}; A = \left(\dfrac{Z}{U S^{v''}\prod_{i=L'+1}^{L} R_i^{m_i}} \right)^{1/e} \mod n$ \\
%$S \longrightarrow R$: $(A, e, v''), PK\{(\delta) : A \equiv \pm \left(\dfrac{Z}{U S^{v''} \prod_{i=L'+1}^{L} R_i^{m_i}} \right)^{\delta} \mod n \}$ \\
%$R$: verify $e \in [2^{l_e-1} + 1, 2^{l_e} -1]$ is prime; $v = v' + v''$

\begin{figure}[ht]
  \centering
  \includegraphics[scale=.45]{mscs/cl_blind-sign}
  \caption{Blind signature generation}
  \label{msc:cl_blind-sign}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[scale=.45]{mscs/cl_blind-sign_pku}
  \caption{$PK\{(\mu_1, \dots, \mu_{L'}, \nu') :
    U \equiv \pm S^{\nu'} \prod_{i=1}^{L'} R_i^{\mu_i} \mod n \;\land\; \mu_1, \dots, \mu_{L'} \in \pm\{0,1\}^{l_m} \}$}
  \label{msc:cl_blind-sign_pku}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[scale=.45]{mscs/cl_blind-sign_pka}
  \caption{$PK\{(\delta) :
  A \equiv \pm \left(\dfrac{Z}{U S^{v''} \prod_{i=L'+1}^{L} R_i^{m_i}} \right)^{\delta} \mod n \}$}
  \label{msc:cl_blind-sign_pka}
\end{figure}

\subsubsection{Signature verification}\label{sec:cl_blind-verify}

As given in Section~\ref{sec:cl_basic-verify}.

\subsection{Signature proving}\label{sec:cl_proof}

\subsubsection{Key Generation}\label{sec:cl_proof-keygen}

As given in Section~\ref{sec:cl_blind-keygen}.

\subsubsection{Signature Generation}\label{sec:cl_proof-sign}

As given in Section~\ref{sec:cl_blind-sign}. Alternatively as given in Section~\ref{sec:cl_basic-sign} with an additional proof that $A \in \langle S \rangle$. This can be derived from correct construction of the signature, together with the correct construction of the keys.

$S \longrightarrow R$: $PK\{(\delta) : A \equiv \pm \left(\dfrac{Z}{U S^{v''} \prod_{i=L'+1}^{L} R_i^{m_i}} \right)^{\delta} \mod n \}$

\subsubsection{Signature Verification}\label{sec:cl_proof-verify}

\paragraph{Input} elements $g_1, \dots, g_L$ where
\begin{description}
  \item[$g_1, \dots, g_L$] $\in G = \langle g_0 \rangle$ where $G$ is a group of prime order $q > 2^{l_m}$ generated by $g_0$
\end{description}

\paragraph{Output}

$R$: $r' \in \{0,1\}^{l_n + l_\varnothing}; C = g_0^{r'} \prod_{i \in I_c} g_i^{m_i}; r \in_R \{0, 1\}^{l_n + l_\varnothing}; A' = A S^r$ \\
$R \longrightarrow V$: $A', C, m_i$ where $i \not\in I_c \cup I_h$,
$PK\{ (\varepsilon, \tilde{\nu}, \rho', \{\mu_i : i \in I_c \cup I_h\}) :
Z A'^{-2^{l_e -1}} \prod_{i \not\in I_c \cup I_h} R_i^{-m_i} \equiv \pm A'^\varepsilon S^{\tilde{\nu}} \prod_{i \in I_c \cup I_h} R_i^{\mu_i} \mod n \land
C \equiv g_0^{\rho'} \prod_{i \in I_c} g_i^{\mu_i} \land
\bigwedge_{i \in I_c \cup I_h} \mu_i \in \{0,1\}^{l_m + l_\varnothing + l_H + 2} \land
\varepsilon \in \pm \{0,1\}^{l'_e + l_\varnothing | l_H + 1} \}$ \\
$V$: verify $m_i \in \pm \{0,1\}^{l_m}$ for $i \not\in I_c \cup I_h$

\section{Credential Verification}

\subsection{Randomisation}

The signature is randomised to prevent linkability based on the signature values $A, e, v$.
First a random blinding value $r_A$ is generated to randomise $A$.
Next the values $e$ and $v$ are adjusted such that the signature remains valid.

\begin{algorithm}[ht]
  \caption{Randomise the signature}
  \addtolength{\baselineskip}{1mm}

  \begin{algorithmic}[1]
    \item[\textbf{Parameters}] $n, S$

    \Statex
    \Function{RandomiseSignature}{$A$, $e$, $v$}
      \State $r_A \gets \Call{RandomBits}{\ell_{n} + \ell_{\o}}$
      \State $A' \gets A \cdot S^{r_A} \mod n$
      \State $e' \gets e - 2^{\ell_{e} - 1}$
      \State $v' \gets v - e \cdot r_A$
      \State \Return $A', e', v'$
    \EndFunction
  \end{algorithmic}
\end{algorithm}

Note that this randomisation operation only effectively randomises the $A$ value of the signature.
Hence it is required to hide the $e'$ and $v'$ using a zero-knowledge proof when revealing this randomised signature.


\subsection{Selective disclosure \& Zero-knowledge proof}

We can distinguish two types of credentials. A root credential which contains the special attributes $a_\mathtt{nym}$ and $a_\mathtt{rev}$, and regular credentials which do not contain these values. The root credential is used when a pseudonym and/or revocation check is required, whereas regular credentials are used to reveal attributes. This can also be combined, either by including attributes in the root credential, or using additional credentials besides the root credential.

All credentials contain the device master secret $s$ which binds the credential to the device. This secret should be stored in a protected manner to prevent cloning of the credentials to other devices. Furthermore, an attribute $a_\mathtt{exp}$ containing expiry information (general enough to prevent identification based on this value) is contained in each credential such that the validity of the credential can be verified. Therefore $a_\mathtt{exp}$ is always revealed during a selective disclosure proof. In contrast, the secret $s$ and attributes $a_\mathtt{nym}$ and $a_\mathtt{rev}$ are never revealed. Any other attributes contained by a credential are denoted as $a_1, \dots, a_l$, where $l$ is the number of attributes. The signature over the credential containing these attributes is the triplet $(A, e, v)$.

We assume that a (secure) session has been established and that any information relevant to this session is captured in the $\mathtt{context}$ variable. When a service provider needs a pseudonym and/or attributes a request is sent containing an attribute disclosure selection $\mathcal{D}$ to indicate which attributes should be revealed and a fresh $\mathtt{nonce}$ to ensure a freshly generated proof.

Algorithm~\ref{alg:proof} describes the operations that have to be performed to generate a selective disclosure proof, including pseudonym and revocation. The first step in this algorithm is to generate the pseudonym and revocation values as well as to randomise the signature. The next step is the zero-knowledge proof which hides the undisclosed attributes and the $e'$ and $v'$ values from the randomised signature. Furthermore this proof binds the pseudonym and revocation values to the signature to guarantee authenticity and correctness of the generated values.

The zero-knowledge proof is constructed in four steps. First a bunch of blinding values is generated to hide all values that are not revealed in this proof. The next step is to commit to these blinding values by calculating the commitments. These commitments are then used to generate the challenge which is the input to the final step, the calculation of the responses. Finally the proof, the challenge and the responses, together with the revealed values are returned.

\begin{algorithm}
  \caption{Prove the attributes}
  \label{alg:proof}
  \addtolength{\baselineskip}{1mm}
  \begin{algorithmic}[1]

    \item[\textbf{Card}] $s$
    \item[\textbf{Credential}] $a_\mathtt{exp}, a_{1 \dots l}, (n, S, Z, R_{s, \mathtt{exp}, 1 \dots l}), (A, e, v)$
    \item[\textbf{Session}] $\mathtt{context}$
    \item[\textbf{Request}] $\mathcal{D}, \mathtt{nonce}$

    \Statex
    \Function{GenerateProof}{}
      \State $A', e', v' \gets \Call{RandomiseSignature}{A, e, v}$

      \Statex \Comment{Generate all blinding values}
      \State $\tilde{e} \gets \Call{RandomBits}{\ell_{e'} + \ell_{\text{\o}} + \ell_{H}}$
      \State $\tilde{v} \gets \Call{RandomBits}{\ell_{v} + \ell_{\o} + \ell_{H}}$
      \State $\tilde{s} \gets \Call{RandomBits}{\ell_{m} + \ell_{\o} + \ell_{H}}$
      \ForAll{$i \notin \mathcal{D}$} \Comment{undisclosed attributes}
        \State $\tilde{a}_i \gets \Call{RandomBits}{\ell_{m} + \ell_{\o} + \ell_{H}}$
      \EndFor

      \Statex \Comment{Compute the commitment}
      \State $\tilde{Z} \gets {A'}^{\tilde{e}} \cdot S^{\tilde{v}} \cdot R_0^{\tilde{s}} \mod n$
      \ForAll{$i \notin \mathcal{D}$} \Comment{undisclosed attributes}
        \State $\tilde{Z} \gets \tilde{Z} \cdot R_i^{\tilde{a}_i} \mod n$
      \EndFor

      \Statex \Comment{Generate the challenge}
      \State $c \gets \Call{Hash}{\mathtt{context} || A' || \mathtt{ID_{nym}} || \mathtt{ID_{rev}} ||
        \tilde{Z} || \mathtt{nonce}}$

      \Statex \Comment{Compute the responses}
      \State $\hat{e} \gets \tilde{e} + c \cdot e'$
      \State $\hat{v} \gets \tilde{v} + c \cdot v'$
      \State $\hat{s} \gets \tilde{s} + c \cdot s$
      \ForAll{$i \notin \mathcal{D}$} \Comment{undisclosed attributes}
        \State $\hat{a}_i \gets \tilde{a}_i + c \cdot a_i$
      \EndFor

      \Statex
      \Return $c, A', \hat{e}, \hat{v}, \hat{s}, \hat{a}_\mathtt{nym}, \hat{a}_\mathtt{rev}, \hat{a}_{i \notin \mathcal{D}}, a_\mathtt{exp}, a_{i \in \mathcal{D}}$
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\subsection{Verification}

Once a service provider receives the attributes $a_{i \in \mathcal{D}}$, the pseudonym $\mathtt{ID_{nym}}$ and device revocation value $\mathtt{ID_{rev}}$ it can just use those to provide its service. However, the proper solution is to first verify the proof generated by the card to assess the validity of these values.

The verification procedure is given in Algorithm~\ref{alg:verify}. This procedure starts with reconstructing the commitments using the responses (and the received challenge). Using these commitments the challenge can be reconstructed which can then be verified with the challenge value received from the card. If these challenges match, the proof is valid, otherwise it is invalid and the received values should not be used for any further processing (except perhaps for reporting this incident). Finally, the service provider should check the $a_{\mathtt{exp}}$ value to determine whether or not the credential has expired.

\begin{algorithm}
  \caption{Verify the attributes}
  \label{alg:verify}
  \addtolength{\baselineskip}{1.5mm}

  \begin{algorithmic}[1]
    \item[\textbf{Session}] $\mathtt{context}$
    \item[\textbf{Request}] $\mathcal{D}, \mathtt{nonce}$
    \item[\textbf{Response}] $c, A', \hat{e}, \hat{v}, \hat{s}, \hat{a}_\mathtt{nym}, \hat{a}_\mathtt{rev}, \hat{a}_{i \notin \mathcal{D}}, a_\mathtt{exp}, a_{i \in \mathcal{D}}$

    \Statex
    \Function{VerifyProof}{}
      \Statex \Comment{Reconstruct the commitments}
      \State $\hat{Z} \gets (A')^{2^{\ell_e - 1}} \cdot R_\mathtt{exp}^{a_\mathtt{exp}} \mod n$
      \ForAll{$i \in \mathcal{D}$} \Comment{disclosed attributes}
        \State $\hat{Z} \gets \hat{Z} \cdot R_i^{a_i} \mod n$
      \EndFor
      \State $\hat{Z} \gets \hat{Z}^c \cdot Z^{-c} \cdot (A')^{\hat{e}} \cdot S^{\hat{v}} \mod n$
      \ForAll{$i \notin \mathcal{D}$} \Comment{undisclosed attributes}
        \State $\hat{Z} \gets \hat{Z} \cdot R_i^{\hat{a}_i} \mod n$
      \EndFor
      \Statex \Comment{Reconstruct the challenge}
      \State $\hat{c} \gets \Call{Hash}{\mathtt{context} || A' || \mathtt{ID_{nym}} || \mathtt{ID_{rev}} ||
        \hat{Z} || \mathtt{nonce}}$
      \Statex \Comment{Verify the challenge}
      \If{$c = \hat{c}$}
        \Return \Call{Valid}{}
      \Else
        \Return \Call{Invalid}{}
      \EndIf
    \EndFunction
  \end{algorithmic}
\end{algorithm}
